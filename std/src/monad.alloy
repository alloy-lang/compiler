module Monad
where

import std::applicative::Applicative

--! A generalised trait for composing sequential actions
trait Monad where
  self = #Type[_] + Applicative

  --! This can be seen as akin to sequential variable binding in an
  --! imperative language. For example in Javascript:
  --!
  --! ```js
  --! var x1 = call_fallible("hello");
  --! var x2 = do_something1(x1);
  --! var x3 = do_something2(x2);
  --! var x4 = do_something3(x3);
  --! ```
  --!
  --! In alloy this would look like:
  --!
  --! ```alloy
  --! import std::monad::Monad
  --!
  --! call_fallible("hello")
  --!   |> Monad::flat_map(do_something1)
  --!   |> Monad::flat_map(do_something2)
  --!   |> Monad::flat_map(do_something3)
  --! ```
  --!
  --! > Note that `flat_map(do_something1)` is short hand for `flat_map(|x| -> do_something1(x))`
  --!
  --! It is sometimes more ergonomic to use the `(>>=)` operator:
  --!
  --! ```alloy
  --! import std::monad::(>>=)
  --!
  --! call_fallible("hello") >>= do_something
  --! ```
  --!
  --! # Note
  --!
  --! * Known as `Option::and_then` and `Result::and_then` in Rust
  --! * Known as `flat_map` or `flat_map` in other languages
  typeof flat_map : (a -> self[b]) -> self[a] -> self[b]
end

--#[infix(right, 1)]
typeof (=<<) : (t1 -> m[t2]) -> m[t1] -> m[t2] where
  typevar m = Monad
  typevar t1
  typevar t2
let (=<<) = Monad::flat_map

--#[infix(left, 1)]
typeof (>>=) : m[t1] -> (t1 -> m[t2]) -> m[t2] where
  typevar m = Monad
  typevar t1
  typevar t2
let (>>=) = |x, f| -> Monad::flat_map(f, x)


typeof join : m[m[t1]] -> m[t1] where
  typevar m = Monad
  typevar t1
let join = |mm| -> (mm >>= |x| -> x)


-- Kleisli composition
--#[infix(right, 9)]
typeof (<=<) : (t2 -> m[t3]) -> (t1 -> m[t2]) -> t1 -> m[t3] where
  typevar m = Monad
  typevar t1
  typevar t2
  typevar t3
let (<=<) = |g, f, x| -> g =<< f(x)

--#[infix(left, 9)]
typeof (>=>) : (t1 -> m[t2]) -> (t2 -> m[t3]) -> t1 -> m[t3] where
  typevar m = Monad
  typevar t1
  typevar t2
  typevar t3
let (>=>) = |f, g, x| -> f(x) >>= g
