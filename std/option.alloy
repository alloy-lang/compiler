module Option
where

import std::eq::Eq
import std::order::Ord
import std::debug::Debug

--! `Option<t>` represents a value `t` which may not exist.
--! `Option<t>` requires a "concrete" type as a type argument
typedef Option<t> =
    | None
    | Some(t)


behavior Eq for Option<t> where
  typevar t = Eq

  eq : Option<t> -> Option<t> -> Bool
  eq = |left, right| ->
    match (left, right) when
      | (Some(l_val), Some(r_val)) -> Eq::eq(l_val, r_val)
      | (None, None) -> True
      | _ -> False


behavior Ord for Option<t> where
  typevar t = Ord

  compare : Option<t> -> Option<t> -> Ordering
  compare = |left, right| ->
    match (left, right) when
      | (Some(l_val), Some(r_val)) -> Ord::compare(l_val, r_val)
      | (None, Some(_)) -> LT
      | (Some(_), None) -> GT
      | (None, None) -> EQ


behavior Debug for Option<t> where
  typevar t = Debug

  debug : Option<t> -> String
  debug = |op| ->
    match op when
      | Some(x) -> "Some(#{x})"
      | None -> "None"


behavior Functor for Option<_> where

  map : (t1 -> t2) -> Option<t1> -> Option<t2> where
    typevar t1
    typevar t2
  map = |convert, x| -> match x when
    | Some(x_val) -> Some(convert(x_val))
    | None        -> None


behavior Applicative for Option<_> where

  apply : Option<(t1 -> t2)> -> Option<t1> -> Option<t2> where
    typevar t1
    typevar t2
  apply = |f, x| -> match (f, x) when
    | (Some(f_val), Some(x_val)) -> Some(f_val(x_val))
    | _                          -> None


  wrap : t1 -> Option<t1> where
    typevar t1
  wrap = |x| -> Some(x)


behavior Monad for Option<_> where

  flat_map : (t1 -> Option<t2>) -> Option<t1> -> Option<t2> where
    typevar t1
    typevar t2
  flat_map = |convert, x| -> match x when
    | Some(x_val) -> convert(x_val)
    | None        -> None
